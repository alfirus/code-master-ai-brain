# Learning Style & Preferences

## How I Learn Best
- **Learning Method**: Code-first, then explanation. Show me working examples before theory
- **Depth Preference**: Deep understanding over quick fixes - want to know "why" not just "how"
- **Pacing**: Step-by-step progression, build complexity gradually
- **Format**: Visual code examples with clear comments, then concept explanation

## Communication Preferences
- **Explanation Style**: Direct and practical, with real-world context
- **Code Comments**: Clear, concise comments that explain "why" not just "what"
- **Error Messages**: Want both the fix and the explanation of why it occurred
- **Documentation**: Prefer JSDoc style for functions, inline examples for complex concepts

## Problem-Solving Approach
- **Method**: Break down complex problems into smaller, testable pieces
- **Debugging**: Start with symptoms, trace back to root cause
- **Validation**: Test assumptions with small experiments before full implementation
- **Iterative**: Build MVP, test, then enhance

## Preferred Information Flow
1. **Here's the problem** - Clear definition of what we're solving
2. **Here's a working solution** - Code that solves the immediate issue
3. **Here's why it works** - Explanation of the underlying concepts
4. **Here's how to adapt it** - Ways to modify for different scenarios
5. **Here's what to watch out for** - Common pitfalls and edge cases

## Mental Models I Use
- **Systems Thinking**: How code pieces connect and affect each other
- **Pattern Recognition**: Identifying reusable solutions across problems
- **Trade-off Analysis**: Understanding pros/cons of different approaches
- **Progressive Disclosure**: Learn basics first, add complexity gradually

## Environment Preferences
- **Work Style**: Focused blocks of time with clear objectives
- **Tool Preferences**: VS Code, Git, Chrome DevTools, Postman
- **Code Review**: Like detailed explanations of changes and their impact
- **Documentation**: Prefer living documentation in code over separate docs

## Anti-Patterns I Dislike
- Over-engineering simple problems
- Magic without explanation
- Solutions without context
- Documentation that doesn't match implementation